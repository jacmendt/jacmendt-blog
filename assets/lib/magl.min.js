"use strict";var magl=function(){var t={},e=["webgl","experimental-webgl","moz-webgl","webkit-3d"];t.createFramebuffer_=function(t,e){var n=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,n);var r=t.createRenderbuffer();t.bindRenderbuffer(t.RENDERBUFFER,r);var o=t.createTexture();return t.bindTexture(t.TEXTURE_2D,o),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,e.width,e.height,0,t.RGBA,t.UNSIGNED_BYTE,null),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,o,0),t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),{fbo:n,texture:o}},t.createProgram=function(t,e,n,r){var o=t.createProgram();if(t.attachShader(o,e),t.attachShader(o,n),void 0!==r&&r===!1)return o;if(t.linkProgram(o),!t.getProgramParameter(o,t.LINK_STATUS))throw"Unable to initialize the shader program.";return o},t.createTextureFromImageData=function(t,e,n,r,o,a,i,c,f){var u=(void 0!==n?n:t.canvas.width,void 0!==r?r:t.canvas.height,void 0!==o?o:t.UNSIGNED_BYTE),l=u===t.UNSIGNED_BYTE?Uint8Array:Float32Array,_=e instanceof HTMLImageElement?e:new l(e),v=void 0!==a?a:t.RGBA,s=(void 0!==i?i:t.NEAREST,void 0!==c?c:t.NEAREST,void 0!==f&&f===!0?t.CLAMP_TO_EDGE:t.REPEAT,void 0!==f&&f===!0?t.CLAMP_TO_EDGE:t.REPEAT,t.createTexture());return t.bindTexture(t.TEXTURE_2D,s),t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,!0),t.texImage2D(t.TEXTURE_2D,0,v,v,u,_),s},t.drawClipspace=function(t,e,n,r){var o=new Float32Array([-1,-1,-1,1,1,-1,1,1]),a=t.createBuffer();t.bindBuffer(t.ARRAY_BUFFER,a),t.bufferData(t.ARRAY_BUFFER,o,t.STATIC_DRAW);var i=t.getAttribLocation(n,r);t.enableVertexAttribArray(i),t.vertexAttribPointer(i,2,t.FLOAT,!1,0,0),t.viewport(0,0,e.width,e.height),t.drawArrays(t.TRIANGLE_STRIP,0,4)},t.drawFullCanvas=function(t,e,n,r,o){var a=void 0!==r?r:"a_position",i=[-1,-1,-1,1,1,-1,1,1],c=void 0!==o&&o,f=t.createBuffer();t.bindBuffer(t.ARRAY_BUFFER,f),t.bufferData(t.ARRAY_BUFFER,new Float32Array(i),t.STATIC_DRAW);var u=t.getAttribLocation(e,a);t.enableVertexAttribArray(u),t.vertexAttribPointer(u,2,t.FLOAT,!1,0,0),t.viewport(0,0,n.width,n.height),c||t.bindFramebuffer(t.Framebuffer,null)},t.initGL=function(t){var e=void 0;try{e=t.getContext("experimental-webgl"),e.viewportWidth=t.width,e.viewportHeight=t.height}catch(t){}return e||alert("Could not initialise WebGL context!"),e},t.isPowerOf2=function(t){return 0==(t&t-1)},t.loadGLContext=function(t){var n=void 0;if(window.WebGLRenderingContext)for(var r=0;r<e.length;r++)try{if(n=t.getContext(e[r]),n&&"function"==typeof n.getParameter)return n}catch(t){throw Error('Could not initialize webgl context with "'+e[r]+'"')}throw Error("Could not find a webgl context.")},t.readTexture=function(e,n,r){if(n instanceof WebGLTexture)return n;if(n instanceof HTMLImageElement||n instanceof HTMLCanvasElement){var o=e.createTexture(),a=void 0!==r&&r;return e.bindTexture(e.TEXTURE_2D,o),a&&e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,!0),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n),t.isPowerOf2(n.width)&&t.isPowerOf2(n.height)?e.generateMipmap(e.TEXTURE_2D):(e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.NEAREST)),e.bindTexture(e.TEXTURE_2D,null),o}throw Error("Unsupported image type")};var n={};n.addOverlayCanvas=function(t){var e=t.getViewport().children[0],n=t.getSize();document.createElement("canvas");return e.insertAdjacentHTML("afterend",'<canvas class="ol-unselectable magl-canvas" width="'+n[0]+'" height="'+n[1]+'">'),e.nextElementSibling},n.assertSamePixelToCoordinateMatrix=function(t,e){if(t.length!==e.length)return!1;for(var n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0},n.calculateHaversineDistance=function(t,e,n){var r=function(t){return t*Math.PI/180},o=void 0!==n?n:6378137,a=r(t[1]),i=r(e[1]),c=(i-a)/2,f=r(e[0]-t[0])/2,u=Math.sin(c)*Math.sin(c)+Math.sin(f)*Math.sin(f)*Math.cos(a)*Math.cos(i);return 2*o*Math.atan2(Math.sqrt(u),Math.sqrt(1-u))},n.calculateResolutionForExtent=function(t,e){var n=(t[2]-t[0])/e[0],r=(t[3]-t[1])/e[1];return Math.max(n,r)};var r=[-1,-1,-1,1,1,-1,1,1],o=[0,0,0,1,1,0,1,1],a=function(t){arguments.length<=1||void 0===arguments[1]?"byte":arguments[1];this.program_=t.createProgram(),this.gl_=t,this.uniformTypeInfo_=void 0,this.positionBuffer_=new Map,this.texcoordBuffer_=new Map,this.textures_=new Map};a.prototype.bindTexture=function(t,e,n){var r=this.gl_,o=this.program_,a=r.getUniformLocation(o,e);if(!a)throw"Uniform location "+e+" is not used in the shader.";return r.activeTexture(r.TEXTURE0+n),r.bindTexture(r.TEXTURE_2D,t),r.uniform1i(a,n),this.textures_.set(e,t),this},a.prototype.createShader=function(t,e){var n=this.gl_,r=this.program_,o=n.createShader(t);if(n.shaderSource(o,e),n.compileShader(o),!n.getShaderParameter(o,n.COMPILE_STATUS))throw"Error compiling shader: "+n.getShaderInfoLog(o);return n.attachShader(r,o),this},a.prototype.createUniformTypeInfo_=function(){var t=this.gl_,e=this.program_,n=t.getProgramParameter(e,t.ACTIVE_UNIFORMS);this.uniformTypeInfo_=new Map;for(var r=0;r<n;++r){var o=t.getActiveUniform(e,r),a=o.type;switch(o.type){case t.INT:a="1i";break;case t.FLOAT:a="1f";break;case t.FLOAT_VEC2:a="2f";break;case t.FLOAT_MAT4:a="Matrix4fv"}this.uniformTypeInfo_.set(o.name,a)}return this},a.prototype.draw=function(){var t=this.gl_,e=this.program_,n=function(n,r){t.bindBuffer(t.ARRAY_BUFFER,r);var o=t.getAttribLocation(e,n);t.enableVertexAttribArray(o),t.vertexAttribPointer(o,2,t.FLOAT,!1,0,0)};if(!this.positionBuffer_.has("name"))throw"Missing positionBuffer.";return n(this.positionBuffer_.get("name"),this.positionBuffer_.get("buffer")),this.texcoordBuffer_.has("name")&&n(this.texcoordBuffer_.get("name"),this.texcoordBuffer_.get("buffer")),t.clearColor(0,0,0,0),t.clear(t.COLOR_BUFFER_BIT),t.enable(t.BLEND),t.drawArrays(t.TRIANGLE_STRIP,0,4),this},a.prototype.linkProgram=function(){var t=this.gl_,e=this.program_;if(t.linkProgram(e),!t.getProgramParameter(e,t.LINK_STATUS))throw"Failed to link program: "+t.getProgramInfoLog(e);return this.useProgram(),this},a.prototype.setDrawQuadrangle=function(t,e,n){var a=this.gl_,i=function(t,e){var n=a.createBuffer();if(a.bindBuffer(a.ARRAY_BUFFER,n),void 0!==e&&e.length>0){var r=a.getAttribLocation(this.program_,e);a.enableVertexAttribArray(r),a.vertexAttribPointer(r,2,a.FLOAT,!1,0,0)}return a.bufferData(a.ARRAY_BUFFER,new Float32Array(t),a.STATIC_DRAW),n};return void 0!==n&&n===!0?this.positionBuffer_.set("buffer",i(r),t):this.positionBuffer_.set("buffer",i(r)),this.positionBuffer_.set("name",t),void 0!==e&&(this.texcoordBuffer_.set("buffer",i(o)),this.texcoordBuffer_.set("name",e)),this},a.prototype.setUniform=function(t,e){var n=this.gl_,r=this.program_,o=Array.prototype.slice.call(arguments,1);void 0===this.uniformTypeInfo_&&this.createUniformTypeInfo_();var a=this.uniformTypeInfo_.has(t)?this.uniformTypeInfo_.get(t):void 0;if(void 0===a)return this;var i=n.getUniformLocation(r,t),c="uniform"+a;return 0==a.indexOf("Matrix")?n[c].call(n,i,!1,e):(Array.prototype.unshift.call(o,i),n[c].apply(n,o)),this},a.prototype.unbindTexture=function(t){var e=this.gl_;return e.activeTexture(e.TEXTURE0+t),e.bindTexture(e.TEXTURE_2D,null),this},a.prototype.useProgram=function(){var t=this.gl_,e=this.program_;return t.useProgram(e),this};var i={};i.compile=function(t,e,n){var r=t.createShader(e);if(t.shaderSource(r,n),t.compileShader(r),!t.getShaderParameter(r,t.COMPILE_STATUS))throw"Error compiling shader: "+t.getShaderInfoLog(r);return r},i.vertex={},i.vertex.SIMPLE_IDENTITY="attribute vec2 a_position;\nvoid main(void) {\ngl_Position = vec4(a_position, 0.0, 1.);\n}",i.vertex.SIMPLE_VERTEX_TEST="attribute vec2 a_position;\nattribute vec2 a_texcoord;\n\nuniform vec2 u_resolution;\n\nvarying vec2 v_texcoord;\n\nvoid main(void) {\nvec2 zeroToOne = a_position / u_resolution;\nvec2 zeroToTwo = zeroToOne * 2.0;\nvec2 clipSpace = zeroToTwo - 1.0;\ngl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\nv_texcoord = a_texcoord;\n}",i.vertex.SIMPLE_POINT="attribute vec3 a_position;\nvoid main(void) {\ngl_Position = vec4(a_position, 1.0);\ngl_PointSize = 2.0;\n}",i.vertex.SIMPLE_POINT_PIXEL="attribute vec2 a_position;\nuniform vec2 u_resolution;\nvoid main(void) {\nvec2 zeroToOne = a_position / u_resolution;\nvec2 zeroToTwo = zeroToOne * 2.0;\nvec2 clipSpace = zeroToTwo - 1.0;\ngl_Position = vec4(clipSpace, 0.0, 1.0);\ngl_PointSize = 10.0;\n}",i.fragment={},i.fragment.SIMPLE_GREY="void main(void) {\ngl_FragColor = vec4(0.5, 0.5, 0.5, 1.0);\n}",i.fragment.SIMPLE_COLOR="#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec4 u_color;\n\nvoid main(void) {\ngl_FragColor = u_color;\n}",i.fragment.SIMPLE_RANDOM="#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\n\nfloat random(vec2 st) {\nreturn fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvoid main(void) {\nvec2 st = gl_FragCoord.xy / u_resolution.xy;\n\nst *= 10.0;\nvec2 ipos = floor(st);\nvec2 fpos = fract(st);\nvec3 color = vec3(random( ipos ));\ngl_FragColor = vec4(color, 1.0);\n}",i.vertex.SIMPLE_VERTEX="attribute vec4 ap;\nattribute vec4 at;\nvarying vec2 vt;\n\nvoid main(void) {\ngl_Position = vec4(ap.xy * vec2(1, -1), 0, 1);\nvt = at.xy;\n}",i.fragment.IDW="precision highp float;\n\nuniform sampler2D u_data;\nuniform vec2 u_resolution;\nuniform float u_power;\nuniform float u_time;\nuniform int u_stations;\nuniform int u_times;\n\nvarying vec2 v_texcoord;\n\nvoid main(void) {\nvec4 d = texture2D(u_data, vec2(0, 0));\nvec2 t = gl_FragCoord * u_resolution;\nfloat dist = distance(t, d.xy * u_resolution);\ngl_FragColor = vec4(v_texcoord.xy, dist, 0.5);\n}",i.fragment.IDW_TEST="precision highp float;\n\nuniform sampler2D u_data;\nuniform vec2 u_resolution;\nuniform float u_power;\nuniform float u_time;\nuniform int u_stations;\nuniform int u_times;\nuniform mat4 u_ptcMatrix;\nuniform vec2 u_distance;\n\n\nvoid main(void) {\nfloat vsum = 0.0;\nfloat wsum = 0.0;\nfor (int i = 0; i < SIZE; i++){\nvec4 data = texture2D(u_data, vec2(i, 0));\nvec4 c = gl_FragCoord;\nfloat x = u_ptcMatrix[0].x * c.x + u_ptcMatrix[0].y * c.y + u_ptcMatrix[0].w;\nfloat y = u_ptcMatrix[1].x * c.x + u_ptcMatrix[1].y * c.y + u_ptcMatrix[1].w;\nfloat dist = distance(data.xy, vec2(x,y));\nfloat weight = 1.0 / pow(dist, u_power);\nvsum += weight * data.w;\nwsum += weight;\n}\nfloat v = wsum == 0.0 ?  0.0 : vsum / wsum;\ngl_FragColor = vec4(1.0, v, v, 1.0);\n}",i.fragment.COLOR={},i.fragment.COLOR.SCALE="precision highp float;\n\nuniform sampler2D u_colorscale;\nuniform sampler2D u_source;\nuniform float u_opacity;\n\nvarying vec2 v_texcoord;\n\nvoid main(void) {\nvec4 c0 = texture2D(u_source, v_texcoord);\nfloat v = c0.r;\nif (c0.a <= 0.0) {\ngl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n} else {\ngl_FragColor = vec4(c0.rgb, u_opacity);\n}\n}",i.fragment.INVERSE_DISTANCE_WEIGHTING={},i.fragment.INVERSE_DISTANCE_WEIGHTING.PIXEL="precision highp float;\n\nuniform sampler2D ud;\nuniform mat4 uptc;\nuniform vec2 ur;\n\nvarying vec2 vt;\n\nvoid main(void) {\nfloat vs = 0.0;\nfloat ws = 0.0;\nvec2 pc = vec2(vt.x * ur.x, vt.y * ur.y);\nfloat x = uptc[0].x * pc.x + uptc[0].y * pc.y + uptc[3].x;\nfloat y = uptc[1].x * pc.x + uptc[1].y * pc.y + uptc[3].y;\nfor (int i = 0; i < SIZE; i++){\nvec4 da = texture2D(ud, vec2((float(i) + 0.5) / float(SIZE), 0));\nfloat di = distance(da.xy, vec2(x,y));\nfloat w = 1.0 / pow(di, 5.0);\nvs += w * da.w;\nws += w;\n}\nif ((x >= 000.0 && x <= 512.0) && (y >= 000.0 && y <= 512.0)){\nfloat v = ws == 0.0 ?  0.0 : vs / ws;\ngl_FragColor = vec4(v, v, v, 1.0);\n} else {\ngl_FragColor = vec4(0.5, 0.5, 1.0, 1.0);\n}\n}",i.fragment.INVERSE_DISTANCE_WEIGHTING.EPSG_3857="precision mediump float;\n\n#define PI 3.141592653589793\n#define R 6378137.0\n\nuniform sampler2D ud;\nuniform mat4 uptc;\nuniform vec2 ur;\nuniform float us;\n\nvarying vec2 vt;\n\nfloat rad(float d) {\nreturn d * PI / 180.0;\n}\n\nfloat havDis(vec2 c1, vec2 c2) {\nfloat l1 = rad(c1.y);\nfloat l2 = rad(c2.y);\nfloat dla2 = (l2 - l1) / 2.0;\nfloat dlo2 = rad(c2.x - c1.x) / 2.0;\nfloat a = sin(dla2) * sin(dla2) + sin(dlo2) * sin(dlo2) * cos(l1) * cos(l2);\nreturn 2.0 * R * atan(sqrt(a), sqrt(1.0 - a));\n}\n\nvec2 to4326(vec2 c1) {\nfloat x = 180.0 * c1.x / (R * PI);\nfloat y = 360.0 * atan(exp(c1.y / R)) / PI - 90.0;\nreturn vec2(x,y);\n}\n\nvec3 hrgb(float mi, float ma, float v) {\nfloat ra = 2.0 * (v - mi) / (ma - mi);\nfloat b = max(0.0, 1.0 * (1.0 - ra));\nfloat r = max(0.0, 1.0 * (ra - 1.0));\nfloat g = 1.0 - b - r;\n   return vec3(r,g,b);\n}\n\nvoid main(void) {\nfloat vs = 0.0;\nfloat ws = 0.0;\nvec2 pc = vec2(vt.x * ur.x, vt.y * ur.y);\nfloat x = uptc[0].x * pc.x + uptc[0].y * pc.y + uptc[3].x;\nfloat y = uptc[1].x * pc.x + uptc[1].y * pc.y + uptc[3].y;\nvec2 c = to4326(vec2(x,y));\nfor (int i = 0; i < HEIGHT; i++){\nvec4 d = texture2D(ud, vec2( (float(us) + 0.5) / float(WIDTH), (float(i) + 0.5) / float(HEIGHT) ) );\nif (d.w != -9999.0) {\nfloat di = havDis(d.xy, c);\nfloat w = 1.0 / pow(di, 5.0);\nvs += w * d.w;\nws += w;\n}\n}\nif ((c.y >= -85.0 && c.y <= 85.0)){\nfloat v = ws == 0.0 ?  0.0 : vs / ws;\ngl_FragColor = vec4(hrgb(0.0, 1.0, v), 1.0);\n} else {\ngl_FragColor = vec4(0.5, 0.5, 1.0, 1.0);\n}\n}",i.fragment.INVERSE_DISTANCE_WEIGHTING.EPSG_4326="precision highp float;\n\n#define PI 3.141592653589793\n#define R 6378137.0\n\nuniform sampler2D ud;\nuniform mat4 uptc;\nuniform vec2 ur;\n\nvarying vec2 vt;\n\nfloat rad(float d) {\nreturn d * PI / 180.0;\n}\n\nfloat havDis(vec2 c1, vec2 c2) {\nfloat l1 = rad(c1.y);\nfloat l1 = rad(c2.y);\nfloat dla2 = (l2 - l1) / 2.0;\nfloat dlo2 = rad(c2.x - c1.x) / 2.0;\nfloat a = sin(dla2) * sin(dla2) + sin(dlo2) * sin(dlo2) * cos(l1) * cos(l2);\nreturn 2.0 * R * atan(sqrt(a), sqrt(1.0 - a));\n}\n\nvoid main(void) {\nfloat vs = 0.0;\nfloat ws = 0.0;\nvec2 pc = vec2(vt.x * ur.x, vt.y * ur.y);\nfloat x = uptc[0].x * pc.x + uptc[0].y * pc.y + uptc[3].x;\nfloat y = uptc[1].x * pc.x + uptc[1].y * pc.y + uptc[3].y;\nfor (int i = 0; i < SIZE; i++){\nvec4 d = texture2D(ud, vec2((float(i) + 0.5) / float(SIZE), 0));\nfloat di = havDis(d.xy, vec2(x,y));\nfloat w = 1.0 / pow(di, 5.0);\nvs += w * d.w;\nws += w;\n}\nif ((x >= 6.0 && x <= 15.0) && (y >= 46.0 && y <= 56.0)){\nfloat v = ws == 0.0 ?  0.0 : vs / ws;\ngl_FragColor = vec4(1.0 - v, 1.0 - v , 0.0, 1.0);\n} else {\ngl_FragColor = vec4(0.5, 0.5, 1.0, 1.0);\n}\n}",i.fragment.TEST_GEO_PROGRAM="precision highp float;\n\n#define PI 3.141592653589793\n#define RADIUS 6378137.0\n\nuniform sampler2D u_data;\nuniform mat4 u_ptcMatrix;\nuniform vec2 u_resolution;\n\nvarying vec2 v_texcoord;\n\nfloat toRadians(float angleInDegrees) {\nreturn angleInDegrees * PI / 180.0;\n}\n\nfloat haversinDistance(vec2 c1, vec2 c2) {\nfloat lat1 = toRadians(c1.y);\nfloat lat2 = toRadians(c2.y);\nfloat deltaLatBy2 = (lat2 - lat1) / 2.0;\nfloat deltaLonBy2 = toRadians(c2.x - c1.x) / 2.0;\nfloat a = sin(deltaLatBy2) * sin(deltaLatBy2) + sin(deltaLonBy2) * sin(deltaLonBy2) * cos(lat1) * cos(lat2);\nreturn 2.0 * RADIUS * atan(sqrt(a), sqrt(1.0 - a));\n}\n\nvoid main(void) {\nfloat vsum = 0.0;\nfloat wsum = 0.0;\nvec2 pxCoord = vec2(v_texcoord.x * u_resolution.x, v_texcoord.y * u_resolution.y);\nfloat x = u_ptcMatrix[0].x * pxCoord.x + u_ptcMatrix[0].y * pxCoord.y + u_ptcMatrix[3].x;\nfloat y = u_ptcMatrix[1].x * pxCoord.x + u_ptcMatrix[1].y * pxCoord.y + u_ptcMatrix[3].y;\nfor (int i = 0; i < SIZE; i++){\nvec4 data = texture2D(u_data, vec2((float(i) + 0.5) / float(SIZE), 0));\nfloat dist = haversinDistance(data.xy, vec2(x,y));\nfloat weight = 1.0 / pow(dist, 5.0);\nvsum += weight * data.w;\nwsum += weight;\n}\nif ((x >= 6.0 && x <= 15.0) && (y >= 46.0 && y <= 56.0)){\nfloat v = wsum == 0.0 ?  0.0 : vsum / wsum;\ngl_FragColor = vec4(1.0 - v, 1.0 - v , 0.0, 1.0);\n} else {\ngl_FragColor = vec4(0.5, 0.5, 1.0, 1.0);\n}\n}",i.fragment.OVERLAY="precision highp float;\n\nuniform sampler2D u_overlay;\nuniform sampler2D u_base;\nuniform float u_opacity;\n\nvarying vec2 v_texcoord;\n\nvoid main(void) {\nvec4 baseColor = texture2D(u_base, v_texcoord);\nvec4 overlayColor = texture2D(u_overlay, vec2(v_texcoord.x, v_texcoord.y));\nif (u_opacity == 0.0) {\ngl_FragColor = vec4(baseColor.rgb, 1.0);\n} else if (u_opacity == 1.0) {\ngl_FragColor = vec4(overlayColor.rgb, 1.0);\n} else {\ngl_FragColor = vec4(mix(baseColor.rgb, overlayColor.rgb, u_opacity), 1.0);\n}\n}",i.fragment.COPY="precision highp float;\nvarying vec2 v_texcoord;\nuniform sampler2D u_texture;\nvoid main(void) {\ngl_FragColor = texture2D(u_texture, v_texcoord);\n}",i.fragment.DRAW="precision highp float;\n\nuniform sampler2D u_overlay;\nuniform sampler2D u_base;\nuniform float u_opacity;\n\nvarying vec2 v_texcoord;\n\nvoid main(void) {\nvec4 baseColor = texture2D(u_base, v_texcoord);\ngl_FragColor = vec4(baseColor.rgb, u_opacity);\n}";var c={};c.vertex={},c.fragment={},c.fragment.V_TEXCOORD="vt",c.fragment.U_RESOLUTION="ur",c.fragment.INVERSE_DISTANCE_WEIGHTING={},c.fragment.INVERSE_DISTANCE_WEIGHTING.U_DATA="ud",c.fragment.INVERSE_DISTANCE_WEIGHTING.U_POWER="up",c.fragment.INVERSE_DISTANCE_WEIGHTING.U_PTCMATRIX="uptc",c.fragment.INVERSE_DISTANCE_WEIGHTING.U_SLICES="us",c.vertex.SIMPLE_VERTEX={},c.vertex.SIMPLE_VERTEX.A_POSITION="ap",c.vertex.SIMPLE_VERTEX.A_TEXCOORD="at",c.vertex.SIMPLE_VERTEX.V_TEXCOORD="vt";var f=function(t){var e=arguments.length<=1||void 0===arguments[1]?"byte":arguments[1],n=arguments.length<=2||void 0===arguments[2]?"EPSG:4326":arguments[2],r=new a(t,e),o="EPSG:4326"===n?i.fragment.INVERSE_DISTANCE_WEIGHTING.EPSG_4326:"EPSG:3857"===n?i.fragment.INVERSE_DISTANCE_WEIGHTING.EPSG_3857:"PIXEL"===n?i.fragment.INVERSE_DISTANCE_WEIGHTING.PIXEL:void 0;if(void 0===!o)throw"the choosen projection is not supported through the idw program";var f=t.getExtension("OES_texture_float"),u=t.getExtension("OES_texture_float_linear");if(!f||!u)throw"no floating point texture support";return r.init=function(e,n){var a="#define HEIGHT "+n+" \n#define WIDTH "+e+" \n"+o;return r.createShader(t.VERTEX_SHADER,i.vertex.SIMPLE_VERTEX).createShader(t.FRAGMENT_SHADER,a).linkProgram().setDrawQuadrangle(c.vertex.SIMPLE_VERTEX.A_POSITION,c.vertex.SIMPLE_VERTEX.A_TEXCOORD),this},r.attachData=function(e,n,r,o,a){var i=void 0!==a?a:0,c=[];e.forEach(function(t){c=c.concat(t)});var f=t.FLOAT,u=new Float32Array(c),l=t.RGBA,_=t.createTexture();return this.bindTexture(_,o,i),t.texImage2D(t.TEXTURE_2D,0,l,n,r,0,l,f,u),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),this},r.render=function(e,n,o,a,i){return r.init(n,o).useProgram().attachData(e,n,o,c.fragment.INVERSE_DISTANCE_WEIGHTING.U_DATA,0).setUniform(c.fragment.U_RESOLUTION,t.canvas.width,t.canvas.height).setUniform(c.fragment.INVERSE_DISTANCE_WEIGHTING.U_PTCMATRIX,i).setUniform(c.fragment.INVERSE_DISTANCE_WEIGHTING.U_SLICES,a).draw().unbindTexture(0),t.finish(),this},r.update=function(e,n,o,a){return r.useProgram().bindTexture(this.textures_.get(c.fragment.INVERSE_DISTANCE_WEIGHTING.U_DATA),c.fragment.INVERSE_DISTANCE_WEIGHTING.U_DATA,0).setUniform(c.fragment.U_RESOLUTION,t.canvas.width,t.canvas.height).setUniform(c.fragment.INVERSE_DISTANCE_WEIGHTING.U_PTCMATRIX,n).setUniform(c.fragment.INVERSE_DISTANCE_WEIGHTING.U_SLICES,e).draw().unbindTexture(0),t.finish(),this},r},u={};return u.olhelper=n,u.program={},u.program.IDWProgram=f,u.utils=t,u}();